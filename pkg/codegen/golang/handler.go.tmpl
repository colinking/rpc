// Code generated by colinking/rpc. DO NOT EDIT.
package {{.PackageName}}

import (
  "context"
	"encoding/json"
	"fmt"
	"io/ioutil"
  "net/http"

	jtd "github.com/jsontypedef/json-typedef-go"
)

type Handler interface {
  {{- range .Routes}}
	// {{.Verb}} {{.Path}}
	{{.HandlerName}}(ctx context.Context, req {{.RequestType}}) ({{.ResponseType}}, error)
  {{- end}}
}

func Register(mux *http.ServeMux, handler Handler) {
	{{- range .Routes}}
  mux.Handle("{{.Path}}", JSONHandler("{{.Verb}}", {{.HandlerName}}RequestSchema, handler.{{.HandlerName}}))
  {{- end}}
}

func JSONHandler[Req any, Res any](verb string, requestSchema jtd.Schema, fn func(ctx context.Context, req Req) (Res, error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var body []byte
		switch verb {
		case "GET":
			rawReq := map[string]any{}
			for k, v := range r.URL.Query() {
				if len(v) == 0 {
					continue
				}
				if len(v) > 1 {
					writeHTTPError(fmt.Errorf("received query parameter %q more than once", k), w)
					return
				}

				rawReq[k] = v[0]
			}

			var err error
			body, err = json.Marshal(rawReq)
			if err != nil {
				writeHTTPError(fmt.Errorf("serializing query parameters: %w", err), w)
				return
			}
		case "POST":
			var err error
			body, err = ioutil.ReadAll(r.Body)
			if err != nil {
				writeHTTPError(fmt.Errorf("reading body: %w", err), w)
				return
			}
		default:
			writeHTTPError(fmt.Errorf("verb+path not found: %s", verb), w)
			return
		}

		var rawReq interface{}
		if err := json.Unmarshal(body, &rawReq); err != nil {
			writeHTTPError(fmt.Errorf("unmarshaling request: %w", err), w)
			return
		}

		errs, err := jtd.Validate(requestSchema, rawReq, jtd.WithMaxDepth(32), jtd.WithMaxErrors(1))
		if err != nil {
			writeHTTPError(fmt.Errorf("validating request: %w", err), w)
			return
		}
		if len(errs) > 0 {
			writeHTTPError(fmt.Errorf("request failed validation: %+v", errs), w)
			return
		}

		// Now that the request is validated, we can unmarshal it into our Req struct.
		var req Req
		if err := json.Unmarshal(body, &req); err != nil {
			writeHTTPError(fmt.Errorf("unmarshaling request into struct: %w", err), w)
			return
		}

		resp, err := fn(r.Context(), req)
		if err != nil {
			writeHTTPError(err, w)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(resp); err != nil {
			writeHTTPError(fmt.Errorf("marshaling response: %w", err), w)
			return
		}
	}
}

func writeHTTPError(err error, w http.ResponseWriter) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusInternalServerError)
	if err := json.NewEncoder(w).Encode(map[string]interface{}{
		"error": fmt.Sprintf("%+v", err),
	}); err != nil {
		w.Write([]byte(`{"error": "Failed to marshal error message"}`))
	}
}
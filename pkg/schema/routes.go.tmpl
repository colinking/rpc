// Code generated by colinking/rpc. DO NOT EDIT.
// TODO: generate Go client
package {{.PackageName}}

import (
  "context"
	"encoding/json"
	"fmt"
	"io/ioutil"
  "net/http"

	jtd "github.com/jsontypedef/json-typedef-go"
)

type Routes interface {
  {{- range .Routes}}
	// {{.Verb}} {{.Path}}
	{{.HandlerName}}(ctx context.Context, request {{.RequestType}}) ({{.ResponseType}}, error)
  {{- end}}
}

func Register(mux *http.ServeMux, routes Routes) {
	// TODO: handle routes that differ only by verb
	{{- range .Routes}}
  mux.Handle("{{.Path}}", JSONHandler("{{.Verb}}", {{.HandlerName}}RequestSchema, routes.{{.HandlerName}}))
  {{- end}}
}

func JSONHandler[Req any, Res any](verb string, requestSchema jtd.Schema, fn func(ctx context.Context, req Req) (Res, error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: assert either JSON content-type or no content-type
		// TODO: handle identical verbs for a given path

		var body []byte
		switch verb {
		case "GET":
			rawReq := map[string]any{}
			for k, v := range r.URL.Query() {
				if len(v) == 0 {
					continue
				}
				if len(v) > 1 {
					// TODO: return as 400 error
					writeHTTPError(fmt.Errorf("received query parameter %q more than once", k), w)
					return
				}

				// TODO: attempt to parse according to type
				rawReq[k] = v[0]
			}

			var err error
			body, err = json.Marshal(rawReq)
			if err != nil {
				writeHTTPError(fmt.Errorf("serializing query parameters: %w", err), w)
				return
			}
		case "POST":
			var err error
			body, err = ioutil.ReadAll(r.Body)
			if err != nil {
				// TODO: return as 400 error
				writeHTTPError(fmt.Errorf("reading body: %w", err), w)
				return
			}
		default:
			// TODO: return as 400 error
			writeHTTPError(fmt.Errorf("verb+path not found: %s", verb), w)
			return
		}

		var rawReq interface{}
		if err := json.Unmarshal(body, &rawReq); err != nil {
			// TODO: return as 400 error
			writeHTTPError(fmt.Errorf("unmarshaling request: %w", err), w)
			return
		}

		errs, err := jtd.Validate(requestSchema, rawReq, jtd.WithMaxDepth(32), jtd.WithMaxErrors(1))
		if err != nil {
			writeHTTPError(fmt.Errorf("validating request: %w", err), w)
			return
		}
		if len(errs) > 0 {
			// TODO: return as 400 error
			// TODO: translate JTD errors into English
			writeHTTPError(fmt.Errorf("request failed validation: %+v", errs), w)
			return
		}

		// Now that the request is validated, we can unmarshal it into our Req struct.
		var req Req
		if err := json.Unmarshal(body, &req); err != nil {
			writeHTTPError(fmt.Errorf("unmarshaling request into struct: %w", err), w)
			return
		}

		// TODO: handle panics
		// TODO: middleware for intercepting errors
		resp, err := fn(r.Context(), req)
		if err != nil {
			// TODO: add errors API for returning specific status codes
			writeHTTPError(err, w)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(resp); err != nil {
			writeHTTPError(fmt.Errorf("marshaling response: %w", err), w)
			return
		}
	}
}

func writeHTTPError(err error, w http.ResponseWriter) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusInternalServerError)
	if err := json.NewEncoder(w).Encode(map[string]interface{}{
		"error": fmt.Sprintf("%+v", err),
	}); err != nil {
		w.Write([]byte(`{"error": "Failed to marshal error message"}`))
	}
}